// content.js
// Bu dosya sayfa üzerinde koşar ve çok sayıda kontrol yapar.
// NOT: Riskli override/patch'ler minimum tutuldu, sadece request-monitoring için fetch/XHR patch yapılır.

let vulnerabilities = [];

// Helper: push vulnerability (benzersiz ID)
function addVuln(id, title, details, type, severity = 'medium', evidence = null) {
  vulnerabilities.push({ id, title, details, type, severity, evidence });
}

// Ana tarama fonksiyonu
function scanPage() {
  vulnerabilities = []; // temizle
  try {
    checkForXSSVulnerabilities();
    checkCookieSecurity();
    checkStorageSecurity();
    checkPasswordFields();
    checkCSP();
    installNetworkMonitor(); // outgoing istekleri izle
    // sonuçları background'a gönder
    chrome.runtime.sendMessage({ action: "vulnerabilitiesDetected", vulnerabilities });
  } catch (e) {
    console.error('scanPage error', e);
  }
}

// 1) XSS kontrolleri (kod arama + DOM tarama)
function checkForXSSVulnerabilities() {
  const pageSource = document.documentElement.outerHTML || '';

  // 1. innerHTML, insertAdjacentHTML, outerHTML kullanımı
  if (/\.\s*innerHTML\s*=?|innerHTML\s*=/.test(pageSource) || pageSource.includes('insertAdjacentHTML') || /outerHTML\s*=/.test(pageSource)) {
    addVuln('xss_dom_write', 'Potansiyel XSS (DOM yazma kullanımı)', 'innerHTML/insertAdjacentHTML/outerHTML gibi DOM yazma çağrıları tespit edildi. Kullanıcı girdisiyle birlikte kullanılıyorsa XSS riski vardır.', 'xss', 'high', { snippet: extractSnippet(pageSource, ['innerHTML','insertAdjacentHTML','outerHTML']) });
  }

  // 2. document.write / writeln
  if (/document\.write\s*\(|document\.writeln\s*\(/.test(pageSource)) {
    addVuln('xss_document_write', 'Potansiyel XSS (document.write)', 'document.write veya document.writeln kullanımı bulundu. Dinamik içerik yazarken dikkatli olun.', 'xss', 'medium');
  }

  // 3. eval, Function constructor, setTimeout/setInterval string argümanları
  if (/\beval\s*\(|new\s+Function\s*\(|setTimeout\s*\(\s*['"`]|setInterval\s*\(\s*['"`]/.test(pageSource)) {
    addVuln('xss_eval_like', 'Riskli dinamik kod çalıştırma', 'eval/new Function veya setTimeout/setInterval(string) görünüyor. Tüm kullanıcı girdileri kontrol edilmeli.', 'xss', 'high');
  }

  // 4. Inline event handler'lar (onclick, onerror, ...)
  const all = document.getElementsByTagName('*');
  for (let el of all) {
    for (let i=0;i<el.attributes.length;i++) {
      const a = el.attributes[i];
      if (/^on/i.test(a.name) && a.value && a.value.trim() !== '') {
        addVuln('xss_inline_handler', 'Inline event handler tespit edildi', `Element ${el.tagName} üzerinde inline handler ${a.name}="${a.value.slice(0,120)}" bulundu.`, 'xss', 'medium', { attr: a.name, value: a.value.slice(0,300) });
      }
    }
  }

  // 5. javascript: URL'leri
  const anchors = document.querySelectorAll('a[href^="javascript:"]');
  if (anchors.length > 0) {
    addVuln('xss_js_url', 'javascript: URL tespit edildi', `${anchors.length} adet javascript: link bulundu. Bunlar XSS için tehlikeli olabilir.`, 'xss', 'low');
  }

  // 6. script.textContent ile dinamik script ekleme tespiti (inline script içeriğini tara)
  const scripts = document.querySelectorAll('script');
  scripts.forEach(s => {
    const content = s.textContent || '';
    if (content && (/\beval\s*\(|new\s+Function\s*\(|document\.write|innerHTML|insertAdjacentHTML/.test(content))) {
      addVuln('xss_inline_script', 'Inline script içinde riskli kullanım', 'Bir <script> içinde eval/innerHTML/document.write/insertAdjacentHTML vb. kullanımı tespit edildi.', 'xss', 'high', { snippet: content.slice(0,300) });
    }
  });

  // 7. kaynak toplama / location.search/hash referansları
  if (/\blocation\.search\b|\blocation\.hash\b/.test(pageSource)) {
    // Eğer aynı sayfada innerHTML gibi varsa birleşik uyarı ver
    addVuln('xss_source_param', 'URL parametreleri kullanımı', 'Kod içinde location.search veya location.hash referansı bulundu. Eğer bu veriler sanitasyon olmadan DOM\'a yazılıyorsa XSS riski vardır.', 'xss', 'medium');
  }

  // 8. createElement('script') + textContent assignment
  if (/createElement\s*\(\s*['"`]script['"`]\s*\)/.test(pageSource) && /\.textContent\s*=/.test(pageSource)) {
    addVuln('xss_dynamic_script', 'Dinamik script oluşturma tespit edildi', 'createElement("script") ile script oluşturulup textContent atanmışsa kötü niyetli kod eklenebilir.', 'xss', 'high');
  }
}

// 2) Cookie güvenliği (client-side kontroller)
function checkCookieSecurity() {
  try {
    const raw = document.cookie || '';
    if (!raw) {
      // boşsa uyarma; bazı sayfalarda HttpOnly cookie olduğu için client göremez
      // ama gene de bilgiyi not et
      // addVuln('cookie_none', 'document.cookie boş', 'document.cookie boş veya HttpOnly cookie kullanılıyor olabilir. HttpOnly cookie güvenlik açısından iyidir.', 'cookie', 'info');
    } else {
      // sensitif anahtar isimleri kontrolü
      const sensitiveKeys = ['token','session','auth','passwd','password','jwt','access'];
      const pairs = raw.split(';').map(s=>s.trim());
      for (let p of pairs) {
        const [k,v] = p.split('=').map(x=>x && x.trim());
        if (!k) continue;
        const lower = k.toLowerCase();
        for (let s of sensitiveKeys) {
          if (lower.includes(s)) {
            addVuln('cookie_sensitive', 'Hassas bilgi içeren cookie', `document.cookie içinde "${k}" benzeri bir anahtar bulundu. Bu cookie client-side erişilebilir olabilir.`, 'cookie', 'high', { cookie: k });
          }
        }
      }

      // HTTPS kontrolü
      if (window.location.protocol !== 'https:') {
        addVuln('cookie_insecure_transport', 'Sayfa HTTPS değil', 'Sayfa HTTPS üzerinden değil; cookie ve form bilgileri zayıf bir bağlantı üzerinden gidiyor olabilir.', 'cookie', 'high');
      }
    }

    // HttpOnly veya Secure kontrolü: Bunları client-side doğrudan göremeyiz.
    // Eğer temiz sunucu header'ına bakmak istersen webRequest kullanmak gerekir (opsiyonel).
  } catch (e) {
    console.error('checkCookieSecurity error', e);
  }
}

// 3) localStorage/sessionStorage güvenlik kontrolleri
function checkStorageSecurity() {
  try {
    const suspectKeys = [];
    for (let i=0;i<localStorage.length;i++) {
      const key = localStorage.key(i);
      const val = localStorage.getItem(key) || '';
      if (/token|auth|session|jwt|passwd|password/i.test(key) || /token|jwt|eyJ[A-Za-z0-9._-]{10,}/.test(val) || val.length > 200) {
        suspectKeys.push({ storage: 'localStorage', key, valueSample: val.slice(0,200) });
      }
    }
    for (let i=0;i<sessionStorage.length;i++) {
      const key = sessionStorage.key(i);
      const val = sessionStorage.getItem(key) || '';
      if (/token|auth|session|jwt|passwd|password/i.test(key) || /token|jwt|eyJ[A-Za-z0-9._-]{10,}/.test(val) || val.length > 200) {
        suspectKeys.push({ storage: 'sessionStorage', key, valueSample: val.slice(0,200) });
      }
    }
    if (suspectKeys.length) {
      addVuln('storage_sensitive', 'Hassas veri local/session storageta', `localStorage/sessionStorage içinde hassas anahtarlar bulundu. Tarayıcı tarafında saklanan hassas veriler çalınabilir.`, 'storage', 'high', { items: suspectKeys });
    }
  } catch (e) {
    console.error('checkStorageSecurity error', e);
  }
}

// 4) Şifre alanları güvenliği
function checkPasswordFields() {
  try {
    const passwordFields = document.querySelectorAll('input[type="password"]');
    if (passwordFields.length === 0) return;

    passwordFields.forEach(field => {
      const form = field.form;
      const nameOrId = field.name || field.id || '(belirtilmemiş)';
      // HTTPS kontrolü
      if (window.location.protocol !== 'https:') {
        addVuln('password_insecure_transport', 'Şifre alanı HTTP üzerinde', `Şifre alanı "${nameOrId}" HTTP (HTTPS değil). Her zaman HTTPS kullanılmalıdır.`, 'password', 'high');
      }

      // autocomplete kontrolü
      if (field.autocomplete !== 'off') {
        addVuln('password_autocomplete', 'Şifre alanında autocomplete açık', `Şifre alanı "${nameOrId}" autocomplete="off" değil. Tarayıcı şifre kaydedebilir.`, 'password', 'low');
      }

      // form method ve action kontrolü
      if (form) {
        const method = (form.method || '').toLowerCase();
        const action = form.action || window.location.href;
        if (method && method !== 'post') {
          addVuln('password_form_method', 'Şifre formu GET methodu kullanıyor', `Şifre formu "${nameOrId}" GET ile gönderiliyor (method="${method}"). POST tercih edilmelidir.`, 'password', 'high', { method });
        }
        if (action && !action.startsWith('https://') && window.location.protocol === 'https:') {
          // sayfa HTTPS ama form action http ise
          addVuln('password_form_action_insecure', 'Şifre formu insecure action', `Form action adresi güvenli değil: ${action}`, 'password', 'high');
        }

        // CSRF token kontrolü: gizli input içinde 'csrf' benzeri isim ara
        const hiddenInputs = form.querySelectorAll('input[type="hidden"]');
        let hasCSRF = false;
        hiddenInputs.forEach(h => {
          const n = (h.name || '').toLowerCase();
          if (n.includes('csrf') || n.includes('token') || n.includes('xsrf')) hasCSRF = true;
        });
        if (!hasCSRF) {
          addVuln('csrf_missing', 'CSRF token eksik görünüyor', `Form "${nameOrId}" içinde CSRF token (hidden input) bulunamadı.`, 'csrf', 'medium');
        }
      } else {
        // form yoksa: JS ile submit ediliyor olabilir; yine uyar
        addVuln('password_no_form', 'Şifre alanı bir form içinde değil', `Şifre alanı "${nameOrId}" herhangi bir <form> etiketinin içinde değil. Doğru gönderim akışının olup olmadığını kontrol edin.`, 'password', 'low');
      }

      // URL'de hassas bilgi kontrolü
      const href = window.location.href || '';
      if (/password=|passwd=|token=|access_token=|jwt=/i.test(href)) {
        addVuln('sensitive_in_url', 'URL içinde hassas bilgi', `URL içinde "password/token/jwt" parametreleri bulunuyor: ${href}`, 'info', 'high');
      }
    });
  } catch (e) {
    console.error('checkPasswordFields error', e);
  }
}

// 5) CSP kontrolü (meta tag bazında)
function checkCSP() {
  try {
    const meta = document.querySelector('meta[http-equiv="Content-Security-Policy"]');
    if (!meta) {
      addVuln('csp_missing', 'CSP eksik', 'Sayfada meta Content-Security-Policy bulunmuyor. CSP header ve/veya meta ile XSS riskleri azaltılabilir.', 'csp', 'medium');
      return;
    }
    const policy = meta.getAttribute('content') || '';
    // Basit kontroller
    if (!/script-src/.test(policy)) {
      addVuln('csp_no_script_src', 'CSP script-src yok veya yetersiz', 'CSP politika içeriğinde script-src direktifi görünmüyor veya çok geniş olabilir.', 'csp', 'medium', { policy: policy.slice(0,300) });
    }
    if (/unsafe-inline|unsafe-eval/.test(policy)) {
      addVuln('csp_unsafe', 'CSP unsafe inline/eval izni var', 'CSP içinde unsafe-inline veya unsafe-eval gördük. Bu XSS riskini artırır.', 'csp', 'high', { policy: policy.slice(0,300) });
    }

  } catch (e) {
    console.error('checkCSP error', e);
  }
}

// 6) Outgoing network monitoring: fetch/XHR patch (sadece sayfadaki istekleri izle, raporla)
function installNetworkMonitor() {
  try {
    if (window.__wg_monitor_installed) return; // birden fazla eklenmesin
    window.__wg_monitor_installed = true;

    // patch fetch
    const origFetch = window.fetch;
    window.fetch = function(input, init) {
      try {
        const url = (typeof input === 'string') ? input : (input && input.url) || '';
        inspectOutgoingRequest(url, init && init.method ? init.method : 'GET');
      } catch(e){ console.error(e); }
      return origFetch.apply(this, arguments);
    };

    // patch XHR
    const OrigXHR = window.XMLHttpRequest;
    function XHRProxy() {
      const xhr = new OrigXHR();
      let _url = '';
      let _method = '';
      const origOpen = xhr.open;
      xhr.open = function(method, url) {
        _method = method;
        _url = url;
        return origOpen.apply(xhr, arguments);
      };
      const origSend = xhr.send;
      xhr.send = function(body) {
        try {
          inspectOutgoingRequest(_url, _method || 'GET', body);
        } catch(e) { console.error(e); }
        return origSend.apply(xhr, arguments);
      };
      return xhr;
    }
    window.XMLHttpRequest = XHRProxy;

  } catch (e) {
    console.error('installNetworkMonitor error', e);
  }
}

function inspectOutgoingRequest(url, method='GET', body=null) {
  try {
    if (!url) return;
    // URL içinde hassas parametre
    if (/password=|passwd=|token=|access_token=|jwt=/i.test(url)) {
      addVuln('outgoing_sensitive_in_url', 'Hassas bilgi GET ile gönderiliyor', `Outgoing istek URL içinde hassas parametreler var: ${truncate(url,200)}`, 'network', 'high');
    }
    // insecure endpoint (http)
    if (url.startsWith('http://')) {
      addVuln('outgoing_insecure_http', 'HTTP üzerinden istek yapılıyor', `Outgoing istek HTTP protokolü kullanıyor: ${truncate(url,200)}. Hassas veriler gönderiliyorsa risklidir.`, 'network', 'high');
    }
    // body içinde password/token gibi
    if (body) {
      try {
        const s = typeof body === 'string' ? body : (JSON && JSON.stringify(body)) || '';
        if (/password=|passwd=|token|jwt|access_token/i.test(s)) {
          addVuln('outgoing_sensitive_body', 'Outgoing istek gövdesinde hassas veri', `İstek gövdesinde password/token gibi ifadeler bulundu: ${truncate(s,300)}`, 'network', 'high');
        }
      } catch (e) {}
    }
  } catch (e) {
    console.error('inspectOutgoingRequest error', e);
  }
}

// Utility helpers
function extractSnippet(src, terms) {
  for (const t of terms) {
    const idx = src.indexOf(t);
    if (idx >= 0) return src.slice(Math.max(0, idx-80), idx+200);
  }
  return src.slice(0,200);
}
function truncate(s, n) { return s && s.length > n ? s.slice(0,n)+'...' : s; }

// Popup veya background'tan gelen scanPage komutunu dinle
chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
  if (request.action === 'scanPage') {
    scanPage();
    // async: sonuçları popup'a ilet
    sendResponse({ vulnerabilities });
    return true;
  }
});

// Optional: otomatik tarama istenirse (manifest storage ile kontrol edilir)
chrome.storage.local.get('scanOnPageLoad', (data) => {
  if (data.scanOnPageLoad) {
    // DOMContentLoaded veya idle durumdan sonra tara
    if (document.readyState === 'complete' || document.readyState === 'interactive') {
      scanPage();
    } else {
      document.addEventListener('DOMContentLoaded', scanPage);
    }
  }
});
